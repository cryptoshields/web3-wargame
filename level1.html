<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>Level 1 ‚Äî ERC20 Approval Trap</title>
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <style>
    body {
      font-family: sans-serif;
      background: linear-gradient(135deg, #1a1a2e, #16213e);
      color: #fff;
      margin: 0;
      overflow-x: hidden;
    }
    .top-bar {
      background: #111;
      padding: 0.8rem 2rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.9rem;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.6);
    }
    .warning-bar {
      background-color: #ff3d00;
      color: #fff;
      padding: 0.75rem;
      text-align: center;
      font-weight: bold;
      font-size: 0.9rem;
    }
    .frame-container {
      display: flex;
      align-items: center;
      justify-content: center;
      height: calc(100vh - 120px);
      position: relative;
    }
    .card {
      background: rgba(0, 0, 0, 0.85);
      border-radius: 12px;
      padding: 2rem;
      box-shadow: 0 0 18px #ff9800;
      max-width: 540px;
      width: 100%;
      text-align: center;
      z-index: 2;
    }
    .button-container {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 1rem;
      margin-top: 1rem;
    }
    button {
      padding: 1rem 2rem;
      font-size: 1rem;
      background: #ff9800;
      border: none;
      border-radius: 8px;
      color: #fff;
      cursor: pointer;
    }
    button:disabled {
      background: #666;
      cursor: not-allowed;
    }
    #status {
      margin-top: 2rem;
      font-size: 1.1rem;
      white-space: pre-wrap;
      text-align: left;
    }
    #nextBtn {
      display: none;
      background: #4caf50;
      padding: 1rem;
      border-radius: 8px;
      color: #fff;
      text-decoration: none;
      margin-top: 2rem;
    }
    .token-drain {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 120px;
      height: 120px;
      margin-top: -60px;
      margin-left: -60px;
      border-radius: 50%;
      background: radial-gradient(circle, red, transparent 70%);
      animation: drain 0.7s ease-out;
      pointer-events: none;
      z-index: 5;
    }
    @keyframes drain {
      0% { transform: scale(0); opacity: 1; }
      100% { transform: scale(10); opacity: 0; }
    }
    .chain-break {
      position: absolute;
      top: 30px;
      right: 30px;
      font-size: 2rem;
      color: #ff3d00;
      animation: pulse 1.5s ease-out;
    }
    @keyframes pulse {
      0% { transform: scale(0.5); opacity: 0.2; }
      100% { transform: scale(1.5); opacity: 0; }
    }
    .overlay-popup {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: #222;
      padding: 1rem 1.5rem;
      border: 2px solid #ff9800;
      color: #fff;
      border-radius: 12px;
      font-size: 1rem;
      z-index: 999;
      animation: fadeOut 3s forwards;
    }
    @keyframes fadeOut {
      0% { opacity: 1; }
      80% { opacity: 1; }
      100% { opacity: 0; display: none; }
    }
    .tooltip-box {
      margin-top: 1.5rem;
      padding: 1rem;
      background: #333;
      border-left: 4px solid #ff9800;
      text-align: left;
      font-size: 0.9rem;
    }
  </style>
</head>
<body>
  <div class="top-bar">
    <div>Approve & Pray</div>
    <div>‚úÖ Survived: <span id="surviveCount">0</span> | üíÄ Drained: <span id="failCount">0</span></div>
  </div>

  <div class="warning-bar">
    ‚ö†Ô∏è This is a testnet simulation. Use a burner wallet with Sepolia ETH only. Never connect a real wallet.
  </div>

  <div class="frame-container">
    <div class="card">
      <h1>üéØ Level 1: Claim WGFAKE</h1>
      <p>This looks like a token reward, but is it safe?</p>
      <div class="button-container">
        <button id="connectBtn">Connect Wallet</button>
        <button id="faucetBtn" disabled>Claim 100 WGFAKE Tokens</button>
        <button id="approveBtn" disabled>Approve Reward (Unlimited)</button>
        <button id="drainBtn" disabled>Drain Tokens (Scammer Action)</button>
        <button id="resetBtn" disabled>Reset Allowance</button>
      </div>
      <div id="status"></div>
      <a href="level2.html" id="nextBtn">‚û°Ô∏è Proceed to Level 2</a>
      <div class="tooltip-box">
        üí° <strong>Did you know?</strong><br>
        ERC20 `approve()` gives another address permission to move your tokens. <br>
        Approvals remain until revoked ‚Äî scammers rely on this to drain your tokens later!
        <br><br>
        For NFTs, the function may look like:<br>
        <code>approve(address to, uint256 tokenId)</code>
        ‚Äî which can expose individual tokens to transfers!
      </div>
    </div>
  </div>

  <script>
    const tokenAddress = "0x2ae3f821fdBad3Fe6A5A84111c4D19E0a2fb0Ed5"; // WG_FakeToken address
    const scammerAddress = "0xf924Fb579fa6360c4424dEEaf74A5a5861792F07"; // New Scammer contract address
    const tokenABI = [
      "function approve(address spender, uint256 amount) public returns (bool)",
      "function allowance(address owner, address spender) public view returns (uint256)",
      "function balanceOf(address account) public view returns (uint256)",
      "function transferFrom(address from, address to, uint256 amount) public returns (bool)",
      "function faucet() external"
    ];
    const scammerABI = [
      "function drain(address token, address victim, uint256 amount) external",
      "function withdraw(address token, uint256 amount) external"
    ];

    const SUPABASE_URL = 'https://wtlsmtfzawyvnozjcbkd.supabase.co';
    const SUPABASE_ANON_KEY = 'your-actual-supabase-anon-key'; // Replace with your Supabase key
    const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

    let provider, signer, token, scammer, userAddress;

    function updateCounters() {
      document.getElementById("surviveCount").textContent = localStorage.getItem("w3game_survived") || 0;
      document.getElementById("failCount").textContent = localStorage.getItem("w3game_failed") || 0;
    }

    async function logResult(result) {
      if (!userAddress) return;
      try {
        await supabase.from("leaderboard_logs").insert({
          address: userAddress.toLowerCase(),
          level: "1",
          outcome: result,
          timestamp: new Date().toISOString()
        });
        console.log("Leaderboard logged:", result);
      } catch (err) {
        console.error("Supabase error:", err);
      }
    }

    function showOverlay(msg) {
      const div = document.createElement("div");
      div.className = "overlay-popup";
      div.innerText = msg;
      document.body.appendChild(div);
      setTimeout(() => div.remove(), 3000);
    }

    function animateTrap() {
      const tokenEffect = document.createElement("div");
      tokenEffect.className = "token-drain";
      document.body.appendChild(tokenEffect);

      const chainBreak = document.createElement("div");
      chainBreak.className = "chain-break";
      chainBreak.innerHTML = "‚õìÔ∏èüí•";
      document.body.appendChild(chainBreak);

      setTimeout(() => {
        tokenEffect.remove();
        chainBreak.remove();
      }, 1000);
    }

    async function checkAllowance() {
      if (!token || !userAddress) return 0;
      const allowance = await token.allowance(userAddress, scammerAddress);
      console.log("Current allowance for scammer:", ethers.utils.formatEther(allowance), "WGFAKE");
      return allowance;
    }

    document.getElementById("connectBtn").onclick = async () => {
      const status = document.getElementById("status");
      if (!window.ethereum) {
        alert("Please install MetaMask.");
        return;
      }
      try {
        status.innerText = "‚è≥ Connecting...";
        provider = new ethers.providers.Web3Provider(window.ethereum);
        await provider.send("eth_requestAccounts", []);
        signer = provider.getSigner();
        userAddress = await signer.getAddress();
        token = new ethers.Contract(tokenAddress, tokenABI, signer);
        scammer = new ethers.Contract(scammerAddress, scammerABI, signer);
        console.log("Token contract initialized at:", tokenAddress);
        console.log("Scammer contract initialized at:", scammerAddress);

        const network = await provider.getNetwork();
        if (network.chainId !== 11155111) {
          status.innerText = "‚ùå Please switch to Sepolia Testnet.";
          return;
        }

        status.innerText = `‚úÖ Connected: ${userAddress}`;
        document.getElementById("faucetBtn").disabled = false;
        document.getElementById("resetBtn").disabled = false;
        const balance = await token.balanceOf(userAddress);
        console.log("User balance:", ethers.utils.formatEther(balance), "WGFAKE");
        document.getElementById("approveBtn").disabled = balance.lt(ethers.utils.parseEther("100"));
        await checkAllowance();
      } catch (err) {
        console.error("Connection error:", err);
        status.innerText = "‚ùå Failed to connect: " + (err.message || "Try again.");
      }
    };

    document.getElementById("faucetBtn").onclick = async () => {
      const status = document.getElementById("status");
      if (!signer || !token) return alert("Connect your wallet first.");
      try {
        status.innerText = "‚è≥ Claiming 100 WGFAKE tokens...";
        const tx = await token.faucet();
        console.log("Faucet tx hash:", tx.hash);
        await tx.wait();
        const balance = await token.balanceOf(userAddress);
        console.log("User balance after faucet:", ethers.utils.formatEther(balance), "WGFAKE");
        status.innerText = `‚úÖ Successfully claimed 100 WGFAKE tokens!\nCurrent balance: ${ethers.utils.formatEther(balance)} WGFAKE`;
        document.getElementById("approveBtn").disabled = balance.lt(ethers.utils.parseEther("100"));
        showOverlay("üéâ Tokens Claimed!");
      } catch (err) {
        console.error("Faucet error:", err);
        status.innerText = "‚ùå Failed to claim tokens: " + (err.reason || err.message || "Try again?");
      }
    };

    document.getElementById("resetBtn").onclick = async () => {
      const status = document.getElementById("status");
      if (!signer || !token) return alert("Connect your wallet first.");
      try {
        status.innerText = "‚è≥ Resetting allowance...";
        const tx = await token.approve(scammerAddress, 0);
        console.log("Reset tx hash:", tx.hash);
        await tx.wait();
        await checkAllowance();
        status.innerText = `‚úÖ Allowance reset! The scammer can no longer transfer your tokens.`;
        showOverlay("üõ°Ô∏è Allowance Reset!");
        document.getElementById("drainBtn").disabled = true;
      } catch (err) {
        console.error("Reset error:", err);
        status.innerText = "‚ùå Failed to reset allowance: " + (err.reason || err.message || "Try again?");
      }
    };

    document.getElementById("approveBtn").onclick = async () => {
      const status = document.getElementById("status");
      if (!signer || !token) return alert("Connect your wallet first.");

      try {
        const balance = await token.balanceOf(userAddress);
        console.log("User balance before approve:", ethers.utils.formatEther(balance), "WGFAKE");
        if (balance.lt(ethers.utils.parseEther("100"))) {
          status.innerText = "‚ùå Insufficient WGFAKE balance. Claim tokens using the faucet first.";
          return;
        }

        status.innerText = "üö® Sending unlimited approval to scammer...";
        const approveAmount = ethers.constants.MaxUint256; // Unlimited approval
        const tx = await token.approve(scammerAddress, approveAmount);
        console.log("Approve tx hash:", tx.hash);
        await tx.wait(); // Wait for approval to be mined
        const allowance = await checkAllowance();
        if (allowance.lt(ethers.utils.parseEther("100"))) {
          status.innerText = `‚ùå Allowance not set correctly. Expected unlimited, got: ${ethers.utils.formatEther(allowance)}. Try resetting and approving again.`;
          return;
        }
        status.innerText = "‚úÖ Unlimited approval sent. The scammer can now drain all your tokens!";
        document.getElementById("drainBtn").disabled = false;
        showOverlay("‚ö†Ô∏è Warning: Your entire token balance is now at risk of being drained!");
      } catch (err) {
        if (err.code === "ACTION_REJECTED") {
          status.innerText = `‚úÖ You survived Level 1!\n\nüõ°Ô∏è You rejected a suspicious approval request.\n\nStay vigilant.`;
          localStorage.setItem("w3game_level1", "survived");
          let surviveCount = parseInt(localStorage.getItem("w3game_survived") || 0);
          localStorage.setItem("w3game_survived", surviveCount + 1);
          updateCounters();
          await logResult("survived");
          document.getElementById("nextBtn").style.display = "inline-block";
        } else {
          console.error("Approve error:", err);
          status.innerText = `‚ö†Ô∏è Error: ${err.reason || err.message || "Try again."}`;
        }
      }
    };

    document.getElementById("drainBtn").onclick = async () => {
      const status = document.getElementById("status");
      if (!signer || !scammer) return alert("Connect your wallet and ensure scammer contract is set up.");

      try {
        status.innerText = "üö® Simulating scammer draining tokens...";
        const balance = await token.balanceOf(userAddress); // Drain the entire balance
        const allowance = await checkAllowance();
        if (allowance.lt(balance)) {
          status.innerText = `‚ùå Insufficient allowance. Current: ${ethers.utils.formatEther(allowance)} WGFAKE. Approve again with unlimited amount.`;
          return;
        }
        const tx = await scammer.drain(tokenAddress, userAddress, balance);
        console.log("Drain tx hash:", tx.hash);
        await tx.wait();
        animateTrap();
        showOverlay("‚ö†Ô∏è Tokens Drained!");
        status.innerText = `üíÄ Tokens Drained!\n\nüëâ Scam Type: ERC20 \`approve()\` + \`transferFrom()\`\nThe scammer used your unlimited approval to take all your tokens.\n\nüõë Reset allowance using the button above or:\nüîó https://revoke.cash\n\nüß† Tip: Always read transactions, and never approve unlimited amounts blindly.`;
        localStorage.setItem("w3game_level1", "drained");
        let failCount = parseInt(localStorage.getItem("w3game_failed") || 0);
        localStorage.setItem("w3game_failed", failCount + 1);
        updateCounters();
        await logResult("drained");
        document.getElementById("nextBtn").style.display = "inline-block";
      } catch (err) {
        console.error("Drain error:", err);
        status.innerText = `‚ö†Ô∏è Error: ${err.reason || err.message || "Check allowance or try resetting."}`;
        if (err.reason === "Not enough allowance") {
          status.innerText += "\nüîç Possible cause: Allowance not updated or insufficient. Try resetting and approving again.";
        }
      }
    };

    window.onload = () => {
      updateCounters();
      document.getElementById("nextBtn").style.display = "none";
      document.getElementById("faucetBtn").disabled = true;
      document.getElementById("approveBtn").disabled = true;
      document.getElementById("drainBtn").disabled = true;
      document.getElementById("resetBtn").disabled = true;
      if (window.ethereum) {
        window.ethereum.on("chainChanged", (chainId) => {
          if (parseInt(chainId) !== 11155111) {
            document.getElementById("status").innerText = "‚ùå Please switch to Sepolia Testnet.";
            document.getElementById("faucetBtn").disabled = true;
            document.getElementById("approveBtn").disabled = true;
            document.getElementById("drainBtn").disabled = true;
            document.getElementById("resetBtn").disabled = true;
            signer = null;
            token = null;
            scammer = null;
          }
        });

        window.ethereum.on("accountsChanged", (accounts) => {
          if (accounts.length === 0) {
            document.getElementById("status").innerText = "‚ùå Wallet disconnected. Please reconnect.";
            document.getElementById("faucetBtn").disabled = true;
            document.getElementById("approveBtn").disabled = true;
            document.getElementById("drainBtn").disabled = true;
            document.getElementById("resetBtn").disabled = true;
            signer = null;
            token = null;
            scammer = null;
          }
        });
      }
    };
  </script>
</body>
</html>
